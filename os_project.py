# -*- coding: utf-8 -*-
"""OS_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V-DM9JNnv1gmIim3GqkVOZ7H-eIkYZxF
"""

# CPU Scheduling System combined with Deadlock Detection and Recovery
# ---> Single CPU core
# ---> Multiple Instances of Several Resource Types

# Takes an InputProcesses.txt file containing a list of processes

# Implements:
# ---> Preemptive Priority scheduling with Round Robin
# ---> Aging: Decrement Priority ( 0 - 20 ) by 1 if in the ready queue for 10 time units
#           --> 0 has the utmost priority
# ---> Deadlock detection and recovery
# ---> Gant chart generation:
#           --> Timeline of process execution
#           --> Average waiting time
#           --> Average Turnaround time
# Reports detected deadlock states and its recovery technique

import re
import matplotlib.pyplot as plt

# Name of the input file consisting of the processes
file_name = "input.txt"

process = {"PID": None,  # process ID
           "arrival_time": None,  # time process enters the system
           "priority": None,
           "state": None,
           "bursts": None,  # list of CPU/IO bursts
           "current_burst_index": None,
           "waiting_time": None,  # total time process spends in the ready queue
           "finish_time": None,  # time when process terminates
           "cpu_remaining": None,
           "ready_queue_entry_time": None}  # time when process last entered the READY queue

ready_queue = []
io_queue = []
waiting_queue = []

system_clock: int = 0  # global simulation clock
running_process = None

process_states = ["NEW",  # process is being created
                  "RUNNING",  # instructions are being executed
                  "WAITING",  # process waiting for some event to occur
                  "READY",  # process is waiting to be assigned to a processor
                  "TERMINATED"]  # process has finished execution

# Scheduler Configuration
TIME_QUANTUM = 5    # round-robin slice
AGING_INTERVAL = 10 # ages every 10 time units
MAX_PRIORITY = 20

def main():
    resources, processes = read_processes_file()

    if not processes:
        print("No valid processes found after validation. Exiting.")
        return
    try:
        validate_resources(resources)
        processes = validate_processes(processes, resources)

        print_processes_details(resources, processes)
        simulate_scheduler(processes, resources)
    except ValueError as e:
        print(e)
        exit(1)



# =================================PROCESS INPUT FILE=================================
def read_processes_file():

    # ensure that the input file exists and was found by the program
    try:
        with open(file_name, "r") as f:
            processes = []
            resources = []
            seen_pids = set()   # ensure no duplicate process IDs
            for line_read in f:
                # clean line of spaces, tabs, and newlines
                line = line_read.strip()
                # skip empty lines
                if not line:
                    continue


                if line.startswith("["): #obtain resources and their instances
                    resources = read_resources(line)

                else:
                    if line[0] in seen_pids:
                        raise ValueError(f"WARNING!! DUPLICATE PID {line[0]} DETECTED")
                    seen_pids.add(line[0])
                    processes.append(read_process(line))
        if not resources:
            raise ValueError("No resources found in the input file!")

        if not processes:
            raise ValueError("No processes found in the input file!")

    # in case the input processes file doesn't exist or error arrises
    except FileNotFoundError:
        print(f"Error: The file '{file_name}' was not found. Please ensure it exists in the same directory as the CPU scheduling script.")
        exit(1)
    except Exception as error:
        print(f"An unexpected error occurred while processing the file: {error}")
        exit(1)
    return resources, processes


# ----------------------Extract resources from input file----------------------
def read_resources(resource_line):
    resources = []

    matches = re.findall(r"\[(.*?)]", resource_line)

    if not matches:
        raise ValueError(f"WARNING!! NO RESOURCES FOUND: {resource_line}!")

    for match in matches:
        tokens = match.split(",")

        if len(tokens) != 2:
            raise ValueError(f"WARNING!! INVALID RESOURCE FORMAT: {match}!")


        resource_id, resource_instances = tokens
        if not resource_id.strip().isdigit() or not resource_instances.strip().isdigit():
            raise ValueError(f"WARNING!! RESOURCE MUST CONTAIN INTEGERS ONLY: {match}!")

        resources.append((int(resource_id), int(resource_instances)))
    return resources


# ----------------------Extract process info from input file----------------------
def read_process(process_line):
    tokens = process_line.split(maxsplit=3)
    if len(tokens) < 4:
        raise ValueError(f"WARNING!! MALFORMED LINE DETECTED IN THE INPUT FILE! EXPECTED 4 FEILDS BUT INSTEAD GOT {len(process_line)} FROM LINE :{process_line}")

    # Enusre no letters or symbols reach the scheduler
    if not tokens[0].isdigit():
        raise ValueError(f"PID {tokens[0]} is not a valid PID")
    if not (tokens[1].isdigit() and int(tokens[1]) >= 0):   # ensures time isnt negative
        raise ValueError(f"ARRIVAL TIME {tokens[1]} is not a valid ARRIVAL TIME")
    if not tokens[2].isdigit():
        raise ValueError(f"PRIORITY {tokens[2]} is not a valid PRIORITY")

    pid = int(tokens[0])
    arrival = int(tokens[1])
    priority = int(tokens[2])
    rest = tokens[3]

    bursts = []
    # Regex to capture content inside CPU{...} or IO{...}
    pattern = r"(CPU\s*\{[^}]+\}|IO\s*\{[^}]+\})"

    matches = re.findall(pattern, rest)

    # ensure cpu or io bursts actually exist for the process before passing to scheduler
    if not matches:
        raise ValueError(f"WARNING!! NO VALID CPU/IO BURSTS FOUND IN LINE {process_line}")

    for burst in matches:

        if burst.startswith("CPU"):
            bursts.append(read_cpu_burst(burst))
        else:
            bursts.append(read_io_burst(burst))

    process = {}
    process["PID"] = pid
    process["arrival_time"] = arrival
    process["bursts"] = bursts
    process["priority"] = priority

    return process


# ----------------------Extract process CPU burst from input file----------------------
def read_cpu_burst(burst_line):
    burst = {
        "type": "CPU",
        "actions": []
    }

    match = re.search(r"\{(.+?)}", burst_line)
    if not match:
        raise ValueError(f"WARNING!! MALFORMED CPU BURST DETECTED IN INPUT FILE:{burst_line}")

    inside_burst = match.group(1).strip()

    if not inside_burst:
        raise ValueError("WARNING!! EMPTY CPU BURST DETECTED IN INPUT FILE:{burst_line}")
    tokens = [t.strip() for t in inside_burst.split(", ")]

    for token in tokens:

        # resource request
        if token.startswith("R"):
            if not re.findall(r"\d+", token):
                raise ValueError(f"WARNING!! INVALID RESOURCE DETECTED IN INPUT FILE:{token}")
            resource, action = map(int, re.findall(r"\d+", token))
            burst["actions"].append(("R",resource, action))

        # resource free
        elif token.startswith("F"):
            if not re.findall(r"\d+", token):
                raise ValueError(f"WARNING!! INVALID RESOURCE FREE DETECTED IN INPUT FILE:{token}")
            resource, action = map(int, re.findall(r"\d+", token))
            burst["actions"].append(("F",resource, action))

        # CPU execution
        else:
            if not token.isdigit():
                raise ValueError(f"WARNING!! INVALID CPU EXECUTION TIME VALUE DETECTED IN INPUT FILE:{token}")

            cpu_time = int(token)
            if cpu_time <=0:
                raise ValueError(f"WARNING!! CPU EXECUTION TIME MUST BE > O. DETECTED {cpu_time}")

            burst["actions"].append(("CPU", cpu_time))

    return burst


# ----------------------Extract process I/O burst from input file----------------------
def read_io_burst(burst_line):
    burst = {}
    burst["type"] = "IO"

    match = re.search(r"\{(\d+)}", burst_line)
    if not match:
        raise ValueError(f"WARNING!! MALFORMED IO BURST DETECTED:{burst_line}")
    duration = int(match.group(1))
    if duration <= 0:
        raise ValueError(f"WARNING!! INVALID IO BURST DURATION:{duration}")
    burst["duration"] = duration

    return burst

# ----------------------Validate structure of input file----------------------
def validate_processes(raw_processes, system_resources):
    """
    Ensures processes adhere to simulation rules:
    1. Priority within range.
    2. Must start and end with CPU bursts.
    3. Resource requests must not exceed total system capacity.
    """
    valid_processes = []
    print("\n--- Performing Static Safety Checks ---")

    resource_capacity = {rid: count for rid, count in system_resources}

    for p in raw_processes:
        pid = p['PID']
        is_valid = True

        # Check Priority
        if not (0 <= p['priority'] <= MAX_PRIORITY):
            raise ValueError(f"[Validation Error] P{pid}: Priority {p['priority']} out of range (0-{MAX_PRIORITY}). Skipping.")
            is_valid = False

        # Check Burst Structure
        if not p['bursts']:
            print(f"[Validation Error] P{pid}: Process has no bursts. Skipping.")
            is_valid = False
        else:
            if p['bursts'][0]['type'] != 'CPU':
                raise ValueError(f"[Validation Error] P{pid}: Must start with a CPU burst.")
                is_valid = False
            if p['bursts'][-1]['type'] != 'CPU':
                raise ValueError(f"[Validation Error] P{pid}: Must end with a CPU burst. Skipping.")
                is_valid = False

        # Check Resource Limits against System Capacity
        if is_valid:
            for burst in p['bursts']:
                if burst['type'] == 'CPU':
                    for action in burst['actions']:
                        if action[0] == 'R':
                            rid = action[1]
                            amt = action[2]

                            if rid not in resource_capacity:
                                raise ValueError(f"[Validation Error] P{pid}: Resource {rid} not in system resources.")
                            total_avail = resource_capacity.get(rid, 0)
                            if amt > total_avail:
                                raise ValueError(f"[Validation Error] P{pid}: Requests R{rid}:{amt} but system only has {total_avail}.")
                                is_valid = False
                                break
                if not is_valid: break

        if is_valid:
            valid_processes.append(p)

    print(f"--- Validation Complete. {len(valid_processes)} processes valid. ---\n")
    return valid_processes



def validate_resources(system_resources):

    print("---Validating System Resources ---")

    if not isinstance(system_resources,( list, tuple)):
        raise ValueError(f"WARNING!! INVALID SYSTEM RESOURCES:{system_resources}. MUST BE A LIST OR TUPLE")
    seen_resources = set()
    for idx, resource in enumerate(system_resources):
        if not isinstance(resource, ( list, tuple)) or len(resource) != 2:
            raise ValueError(f"WARNING!! INVALID RESOURCE ENTRY:{resource}.")

        rid, count = resource

        # check type

        if not isinstance(rid, int) or not isinstance(count, int):
            raise ValueError(f"Resource {resource}:MUST CONTAIN INTEGERS ONLY.")

        # check value

        if rid <=0:
            raise ValueError(f"WARNING!! INVALID RESOURCE ID:{rid}")
        if count <= 0:
            raise ValueError(f"WARNING!! INVALID RESOURCE COUNT:{count}")

        # ensure no duplicate resource id's
        if rid in seen_resources:
            raise ValueError(f"WARNING!! DUPLICATE RESOURCE ID DETECTED:{rid}")
        seen_resources.add(rid)

    print(f"---Resource Validation Complete. {len(seen_resources)} resources valid. ---\n")


def print_processes_details(resources, processes):
    print("Resources:")
    for r in resources:
        print(r)
    print("\nProcesses:")
    for p in processes:
        print("\nPID:", p["PID"])
        print("Arrival Time:", p["arrival_time"])
        print("Priority:", p["priority"])
        print("Bursts:")
        for b in p["bursts"]:
            if b["type"] == "CPU":
                print(" CPU:")
                for act in b["actions"]:
                    print(" ", act)
            else:
                print(" IO:", b["duration"])


# =================================PROCESS SCHEDULING=================================
# -------------------------> UPDATE QUEUES <--------------------------
# 1. Handle Process Arrivals
# 2. Handle I/O completion
# 3. Aging
# -------------------------> DISPATCH TO CPU <------------------------
# 4. Dispatch
# -------------------------> WORK AND CLOCK <-------------------------
# 5. Execute 1 time unit
# 6. Advance the system clock
# -------------------------> COMPLETION CHECKS <----------------------
# 7. Handle CPU completion
# 8. Handle time-slice expiration

def simulate_scheduler(processes, resources):

    global system_clock, ready_queue, running_process, io_queue
    available_resources = {rid: count for rid, count in resources}

    system_clock = 0
    ready_queue.clear()
    io_queue.clear()
    running_process = None
    waiting_queue.clear()

    gantt_log = []
    terminated_list = []
    deadlock_log = []

    # initialize state of every process
    for p in processes:
        p["state"] = "NEW"
        p["initial_priority"] = None
        p["waiting_time"] = 0
        p["ready_queue_entry_time"] = 0
        p["current_burst_index"] = 0
        p["current_action_index"] = 0
        p["io_remaining"] = 0
        p["finish_time"] = None
        p["cpu_remaining"] = None
        p["total_cpu_time_needed"] = sum(act[1] for b in p["bursts"] if b["type"] == "CPU" for act in b["actions"] if act[0] == "CPU")
        p["held_resources"] = {}
        p["requesting"] = None

    quantum_time_remaining = 0  # quantum tracking

    print("\n--- Simulation Start ---")

    while len(terminated_list) < len(processes):
        # 1. Handle arrivals of processes at start of time interval
        for p in processes:
            if p["state"] == "NEW" and p["arrival_time"] == system_clock:
                p["initial_priority"] = p["priority"]
                p["state"] = "READY"
                p["ready_queue_entry_time"] = system_clock
                ready_queue.append(p)
                # make ready queue priority ordered
                ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                print(f"Time {system_clock}: Process {p['PID']} admitted to READY queue")

                # Preempt on higher priority arrival
                if running_process and ready_queue and ready_queue[0]["priority"] < running_process["priority"]:
                    print(f"Time: {system_clock}: Process {running_process['PID']} preempted by {ready_queue[0]['PID']}")
                    running_process["state"] = "READY"
                    running_process["ready_queue_entry_time"] = system_clock
                    ready_queue.append(running_process)
                    ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                    running_process = None

        # 2. Handle I/O completions
        for p in io_queue[:]:
            if p["io_remaining"] == 0:
                p["current_burst_index"] += 1
                p["current_action_index"] = 0
                p["state"] = "READY"
                p["ready_queue_entry_time"] = system_clock
                io_queue.remove(p)
                ready_queue.append(p)
                # make ready queue priority ordered
                ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                print(f"Time {system_clock}: Process {p['PID']} completed I/0 and returned to READY queue")

                # preempt if higher priority process is unblocked
                if running_process and ready_queue and ready_queue[0]["priority"] < running_process["priority"]:
                    print(f"Time: {system_clock}: Process {running_process['PID']} preempted by {ready_queue[0]['PID']}")
                    running_process["state"] = "READY"
                    running_process["ready_queue_entry_time"] = system_clock
                    ready_queue.append(running_process)
                    ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                    running_process = None
        # 3. Aging
        # Prevents starvation by boosting priority of processes waiting too long
        aged = False
        for p in ready_queue:
            if system_clock - p["ready_queue_entry_time"] >= AGING_INTERVAL:
                if p["priority"] > 0:
                    p["priority"] -= 1
                    p["ready_queue_entry_time"] = system_clock
                    print(f"Time {system_clock}: Process {p['PID']} aged, new priority = {p['priority']}")
                    aged = True
        # if aging changed priorities, check for preemption
        if aged:
            ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
            # preempt if higher priority process is unblocked
            if running_process and ready_queue and ready_queue[0]["priority"] < running_process["priority"]:
                print(f"Time: {system_clock}: Process {running_process['PID']} preempted by {ready_queue[0]['PID']}")
                running_process["state"] = "READY"
                running_process["ready_queue_entry_time"] = system_clock
                ready_queue.append(running_process)
                ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                running_process = None

        # 4. Check Waiting Queue
        # Try to unblock processes waiting for resources (resources might have been freed in previous cycle)
        check_waiting_queue(waiting_queue, ready_queue, available_resources, system_clock)

        # 5. Priority-Based Dispatch CPU if idle
        while running_process is None and ready_queue:
            # make ready queue priority ordered
            ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
            running_process = ready_queue.pop(0)
            running_process["waiting_time"] += system_clock - running_process["ready_queue_entry_time"]

            running_process["state"] = "RUNNING"
            quantum_time_remaining = TIME_QUANTUM

            burst = running_process["bursts"][running_process["current_burst_index"]]
            # Fast-forward through non-CPU actions (Requests/Releases)
            # We process instant events until we hit a compute action or get blocked
            while running_process["current_action_index"] < len(burst["actions"]):
                action = burst["actions"][running_process["current_action_index"]]

                if action[0] == "CPU":
                    if running_process["cpu_remaining"] is None:
                        running_process["cpu_remaining"] = action[1]
                    print(f"Time {system_clock}: Process {running_process['PID']} dispatched to CPU")
                    break  # Stop to execute CPU time
                else:
                    print(f"Time {system_clock}: Process {running_process['PID']} executes action {action}")
                    # CALL RESOURCE ALLOCATION FUNCTION
                    if action[0] == "R":
                        print("RESOURCE REQUESTED")
                        resource_id, resource_amount = action[1], action[2]
                        if resource_amount <=0:
                            raise ValueError(f"Invalid resource request amount {resource_amount} by Process{running_process['PID']}")
                        if resource_id not in available_resources:
                            raise KeyError(f"Process {running_process['PID']} requested an unknown resource: {resource_id} is not available")
                        if available_resources.get(resource_id, 0) >= resource_amount:
                            available_resources[resource_id] -= resource_amount
                            running_process["held_resources"][resource_id] = running_process["held_resources"].get(resource_id, 0) + resource_amount
                            print(f"Time {system_clock}: Process {running_process['PID']} requested R{resource_id}:{resource_amount} -> GRANTED")
                            running_process["current_action_index"] += 1

                        else:
                            print(f"Time {system_clock}: Process {running_process['PID']} requested R{resource_id}:{resource_amount} -> BLOCKED")
                            running_process["state"] = "WAITING"
                            running_process["requesting"] = {"rid": resource_id, "amt": resource_amount}
                            waiting_queue.append(running_process)
                            running_process = None
                            break  # Process blocked, stop dispatching

                    # CALL RESOURCE RELEASE FUNCTION
                    elif action[0] == "F":
                        print("RESOURCE FREED")
                        resource_id, resource_amount = action[1], action[2]

                        if resource_id not in running_process["held_resources"]:
                            raise ValueError(f"Process {running_process['PID']} attempted to free R{resource_id} it doesn't hold!")
                        if running_process["held_resources"][resource_id] < resource_amount:
                            raise ValueError(f"Process {running_process['PID']} attempted to free more R{resource_id} than it holds!")

                        available_resources[resource_id] = available_resources.get(resource_id, 0) + resource_amount
                        running_process["held_resources"][resource_id] -= resource_amount
                        if running_process["held_resources"][resource_id] == 0:
                            del running_process["held_resources"][resource_id]
                        print(f"Time {system_clock}: Process {running_process['PID']} released R{resource_id}:{resource_amount}")
                        running_process["current_action_index"] += 1

                        # Check if this release unblocks anyone
                        check_waiting_queue(waiting_queue, ready_queue, available_resources, system_clock)

        # 7. Deadlock Detection
        # Only run if processes are waiting and CPU is idle/empty (potential deadlock state)
        if waiting_queue and not ready_queue and running_process is None:

            deadlocked_pids = detect_deadlock(processes, available_resources)

            if deadlocked_pids:
                print(f"\n[DEADLOCK DETECTED at Time {system_clock}] Processes: {deadlocked_pids}")

                victim = recover_from_deadlock(
                    processes,
                    deadlocked_pids,
                    available_resources,
                    ready_queue,
                    waiting_queue
                )

                victim_pid = victim['PID'] if victim else None
                deadlock_log.append((system_clock, deadlocked_pids, victim_pid))

                if victim:
                    print(f"[RECOVERY] Aborting Process {victim['PID']}. Resources reclaimed.")
                    victim["state"] = "ABORTED"
                    victim["finish_time"] = system_clock
                    terminated_list.append(victim)

                    if victim["held_resources"]:
                        raise ValueError(f"SIMULATION STOPPED:Process {victim['PID']} terminated without releasing resources")

                    if running_process == victim:
                        running_process = None
                    # Try to unblock processes after recovery
                check_waiting_queue(waiting_queue, ready_queue, available_resources, system_clock)

                # Restart loop without consuming a time unit (prevents logging IDLE)
                continue

        # Execute CPU (1 Unit of Time) and log gantt chart
        if running_process and running_process["cpu_remaining"] > 0:
            running_process["cpu_remaining"] -= 1
            # decrement quantum while running
            quantum_time_remaining -= 1
            gantt_log.append(running_process["PID"])
        else:
            gantt_log.append("IDLE")

        for p in io_queue:
            p["io_remaining"] -= 1

        # Advance system clock
        system_clock += 1

        # 8. Check CPU Action Completion
        if running_process and running_process["cpu_remaining"] == 0:
            burst = running_process["bursts"][running_process["current_burst_index"]]
            running_process["current_action_index"] += 1
            running_process["cpu_remaining"] = None

            while running_process["current_action_index"] < len(burst["actions"]):
                action = burst["actions"][running_process["current_action_index"]]
                if action[0] == "CPU":
                    if running_process["cpu_remaining"] is None:
                        running_process["cpu_remaining"] = action[1]
                    print(f"Time {system_clock}: Process {running_process['PID']} continues CPU")
                    break
                else:
                    print(f"Time {system_clock}: Process {running_process['PID']} executes action {action}")
                    # CALL RESOURCE ALLOCATION FUNCTION
                    if action[0] == "R":
                        print("RESOURCE REQUESTED")
                        resource_id, resource_amount = action[1], action[2]
                        if resource_amount <=0:
                            raise ValueError(f"Invalid resource request amount {resource_amount} by Process{running_process['PID']}")
                        if resource_id not in available_resources:
                            raise KeyError(f"Process {running_process['PID']} requested an unknown resource: {resource_id} is not available")
                        if available_resources.get(resource_id, 0) >= resource_amount:
                            available_resources[resource_id] -= resource_amount
                            running_process["held_resources"][resource_id] = running_process["held_resources"].get(resource_id, 0) + resource_amount
                            print(f"Time {system_clock}: Process {running_process['PID']} requested R{resource_id}:{resource_amount} -> GRANTED")
                            running_process["current_action_index"] += 1

                        else:
                            print(f"Time {system_clock}: Process {running_process['PID']} requested R{resource_id}:{resource_amount} -> BLOCKED")
                            running_process["state"] = "WAITING"
                            running_process["requesting"] = {"rid": resource_id, "amt": resource_amount}
                            waiting_queue.append(running_process)
                            running_process = None
                            break  # Process blocked, stop dispatching

                            # CALL RESOURCE RELEASE FUNCTION
                    elif action[0] == "F":
                        print("RESOURCE FREED")
                        resource_id, resource_amount = action[1], action[2]
                        available_resources[resource_id] = available_resources.get(resource_id, 0) + resource_amount
                        running_process["held_resources"][resource_id] -= resource_amount
                        if running_process["held_resources"][resource_id] == 0:
                            del running_process["held_resources"][resource_id]
                        print(f"Time {system_clock}: Process {running_process['PID']} released R{resource_id}:{resource_amount}")
                        running_process["current_action_index"] += 1
                        # Check if this release unblocks anyone
                        check_waiting_queue(waiting_queue, ready_queue, available_resources, system_clock)
                        if running_process and ready_queue:
                            if ready_queue[0]["priority"] < running_process["priority"]:
                                print(f"Time: {system_clock}: Process {running_process['PID']} preempted by {ready_queue[0]['PID']} (Resource Released)")
                                running_process["state"] = "READY"
                                running_process["ready_queue_entry_time"] = system_clock
                                ready_queue.append(running_process)
                                ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                                running_process = None
                                break  # Exit the action loop to allow context switch
            # Check if entire Burst is finished
            if running_process is None:
                continue

            if running_process and running_process["current_action_index"] >= len(burst["actions"]):
                running_process["current_burst_index"] += 1
                running_process["current_action_index"] = 0

                if running_process["priority"] != running_process["initial_priority"]:
                    running_process["priority"] = running_process["initial_priority"]
                    print(f"{system_clock}: Process {running_process['PID']}'s priority is reset to its original priority = {running_process['priority']}")

                if running_process["current_burst_index"] >= len(running_process["bursts"]):
                    # RELEASE ALL HELD RESOURCES ON NORMAL TERMINATION
                    if running_process["held_resources"]:
                        for rid, amt in running_process["held_resources"].items():
                            available_resources[rid] = available_resources.get(rid, 0) + amt
                            print(
                                f"Time {system_clock}: Process {running_process['PID']} auto-released R{rid}:{amt} on termination"
                            )
                        running_process["held_resources"].clear()

                    # Try to unblock waiting processes
                    check_waiting_queue(waiting_queue, ready_queue, available_resources, system_clock)

                    # Now terminate
                    running_process["state"] = "TERMINATED"
                    running_process["finish_time"] = system_clock
                    print(f"Time {system_clock}: Process {running_process['PID']} TERMINATED")
                    terminated_list.append(running_process)

                    if running_process["held_resources"]:
                        raise ValueError(f"SIMULATION STOPPED:Process {running_process['PID']} terminated without releasing resources")
                    running_process = None
                else:
                    # Next burst is I/O -> Block
                    next_burst = running_process["bursts"][running_process["current_burst_index"]]
                    if next_burst["type"] == "IO":
                        running_process["state"] = "WAITING"
                        running_process["io_remaining"] = next_burst["duration"]
                        io_queue.append(running_process)
                        print(
                            f"Time {system_clock}: Process {running_process['PID']} blocked for I/O (duration = {next_burst['duration']})")
                        running_process = None

        # 9. Time Slice Expiration (Round Robin)
        if running_process and quantum_time_remaining == 0:
            # Check if there are other processes with the same priority
            same_priority_processes = [p for p in ready_queue if p["priority"] == running_process["priority"]]

            if same_priority_processes:
                print(f"Time {system_clock}: Time slice expired for {running_process['PID']} (Round-Robin among same priority processes)")
                running_process["state"] = "READY"
                running_process["ready_queue_entry_time"] = system_clock
                ready_queue.append(running_process)
                ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))
                running_process = None
            else:
                # no other process with same priority
                quantum_time_remaining = TIME_QUANTUM

    generate_report(terminated_list, gantt_log, deadlock_log)
    plot_gantt_chart(terminated_list, gantt_log)



def check_waiting_queue(waiting_queue, ready_queue, available_resources, system_clock):
    """
    Scans the waiting queue to see if blocked processes can now satisfy their
    resource requests given the current available resources.
    """
    waiting_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))

    for p in waiting_queue[:]:
        req = p["requesting"]
        if req:
            rid, amt = req["rid"], req["amt"]
            if available_resources.get(rid, 0) >= amt:
                # Grant resource
                available_resources[rid] -= amt
                p["held_resources"][rid] = p["held_resources"].get(rid, 0) + amt
                p["requesting"] = None

                # Move to Ready
                p["state"] = "READY"
                p["ready_queue_entry_time"] = system_clock
                waiting_queue.remove(p)
                ready_queue.append(p)
                ready_queue.sort(key=lambda x: (x["priority"], x["ready_queue_entry_time"]))

                print(f"Time {system_clock}: Res {rid}:{amt} granted to Process {p['PID']} -> READY")
                p["current_action_index"] += 1


# ================================= DEADLOCK LOGIC =================================

def detect_deadlock(processes, available):
    """
    Checks if the system is in a deadlock state.
    Simulates if processes can finish given current resources (Safe Sequence check).
    Processes that cannot finish are considered deadlocked.
    """
    work = available.copy()
    finish = {}

    # Initialize finish status
    for p in processes:
        if p["state"] in ["TERMINATED", "ABORTED"]:
            finish[p["PID"]] = True
        elif p["state"] == "WAITING" and p["requesting"] is not None:
            finish[p["PID"]] = False
        else:
            # Processes not waiting on resources are effectively "safe" for this check
            # (In reality, we assume they will return their resources eventually)
            finish[p["PID"]] = True
            for rid, amt in p["held_resources"].items():
                work[rid] = work.get(rid, 0) + amt

    blocked_procs = [p for p in processes if not finish[p["PID"]]]

    # Iterate to find a safe sequence
    while True:
        progress_made = False
        for p in blocked_procs:
            pid = p["PID"]
            if not finish[pid]:
                needed = {p["requesting"]["rid"]: p["requesting"]["amt"]}

                can_allocate = True
                for rid, amt in needed.items():
                    if amt > work.get(rid, 0):
                        can_allocate = False
                        break

                if can_allocate:
                    # Assume process finishes and returns resources
                    for rid, amt in p["held_resources"].items():
                        work[rid] = work.get(rid, 0) + amt
                    finish[pid] = True
                    progress_made = True

        if not progress_made:
            break

    # Return list of PIDs that could not finish
    return [pid for pid, done in finish.items() if not done]


def recover_from_deadlock(processes, deadlocked_pids, available_resources, ready_queue, waiting_queue):
    """
    Selects a victim from the deadlocked processes to abort.
    Strategy: Abort the process holding the MOST resources to free up the system.
    """
    victim = None
    max_held = -1
    for p in processes:
        if p["PID"] in deadlocked_pids:
            total_held = sum(p["held_resources"].values())
            if total_held > max_held:
                max_held = total_held
                victim = p

    if victim:
        # Reclaim resources
        for rid, amt in victim["held_resources"].items():
            available_resources[rid] = available_resources.get(rid, 0) + amt
        victim["held_resources"] = {}

        # Remove from queues
        if victim in ready_queue: ready_queue.remove(victim)
        if victim in waiting_queue: waiting_queue.remove(victim)

    return victim


def generate_report(terminated_list, gantt_log, deadlock_log):
    print("\n\n================ FINAL STATISTICS ================")

    print(f"Detected Deadlocks: {len(deadlock_log)}")
    print(f"{'Time':<8} | {'Deadlocked Processes':<30} | {'Resolution Strategy'}")
    print("-" * 70)
    for t, pids, victim_pid in deadlock_log:
        resolution = f"Terminated Process {victim_pid}" if victim_pid is not None else "None (Manual Intervention?)"
        print(f"{t:<8} | {str(pids):<30} | {resolution}")

    total_turnaround_time = 0
    total_waiting_time = 0
    valid_count = 0
    killed_processes = []


    print("\n=====GANTT CHART=====")
    if gantt_log:
        curr_process = gantt_log[0]
        start_time = 0
        for t, p_id in enumerate(gantt_log):
            if p_id != curr_process:
                print(f"[{start_time:03} - {t:03}]: Process {curr_process}")
                curr_process = p_id
                start_time = t
        print(f"[{start_time:03} - {len(gantt_log):03}]: Process {curr_process}")


    print("\n=====PERFORMANCE METRICS=====")
    print(f"{'PID':<5} | {'Arrival':<8} | {'Finish':<8} | {'Turnaround':<12} | {'Waiting':<8}")
    print("-" * 55)

    for p in sorted(terminated_list, key=lambda x: x["PID"]):
        if p["state"] == "ABORTED":
            killed_processes.append(p)
            print(f"{p['PID']:<5} {p['arrival_time']:<5} {p['finish_time']:<5} {'-':<5} {'-':<5} {'KILLED':<5} {'-':<5}")
            continue

        if p["finish_time"] == 0: continue

        # Calculate Waiting Time: TAT - Burst Time (CPU + IO)
        turnaround = p["finish_time"] - p["arrival_time"]
        total_io = sum(b["duration"] for b in p["bursts"] if b["type"] == "IO")
        waiting = turnaround - p["total_cpu_time_needed"] - total_io

        total_turnaround_time += turnaround
        total_waiting_time += waiting
        valid_count += 1

        print(f"{p['PID']:<5} | {p['arrival_time']:<8} | {p['finish_time']:<8} | {turnaround:<12} | {waiting:<8}")

    if killed_processes:
        print("\n--- Deadlock Resolution Log (Killed Processes) ---")
        for p in killed_processes:
            print(f"PID {p['PID']}: Killed at Time {p['finish_time']}")

    if valid_count > 0:
        print(f"AVERAGE TURNAROUND TIME: {total_turnaround_time / valid_count:.2f}")
        print(f"AVERAGE WAITING TIME: {total_waiting_time / valid_count:.2f}")
    else:
        print("\nNo processes terminated normally.")



def plot_gantt_chart(terminated_list, gantt_log):
    if not gantt_log:
        print("GANTT LOG EMPTY")
        return

    aborted_pids = {p["PID"] for p in terminated_list if p["state"] == "ABORTED"}

    # convert lof to intervals (PID, start, duration)
    intervals, start_pid, start_time = [], gantt_log[0], 0

    for t, pid in enumerate(gantt_log):
        if pid != start_pid:
            intervals.append((start_pid, start_time, t - start_time))
            start_pid, start_time = pid, t

    intervals.append((start_pid, start_time, len(gantt_log) - start_time))
    figure, axes = plt.subplots(figsize=(12, 4))
    for pid, start, duration in intervals:
        if pid == 'IDLE':
            color = 'lightgray'

        elif pid in aborted_pids:
                color = "red"
        else:
            color = f"C{int(pid) % 10}"
        axes.barh(0, duration, left=start, color=color, edgecolor='black')
        axes.text(start + duration / 2, 0, str(pid) if pid != 'IDLE' else 'IDLE', ha='center', va='center', fontsize=9,
                  fontweight='bold')

    # axes formatting
    axes.set_yticks([0])
    axes.set_yticklabels(['CPU'])
    axes.set_xlabel('System Clock Time Units', fontweight='bold')
    axes.set_title('CPU Scheduling Gantt Chart', fontsize=12, fontweight='bold')
    axes.set_xlim(0, len(gantt_log))
    axes.grid(True, axis='x', linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()